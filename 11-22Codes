자료구조와 알고리즘 11-20강

11강.
실습 작성 코드
def solution(expr):
    match = {
        ')': '(',
        '}': '{',
        ']': '['
    }
    S = ArrayStack()
    for c in expr:
        if c in '({[':
            S.push(c)
        elif c in match:
            if S.isEmpty():
                return False
            else:
                t=S.pop()
                if t != match[c] or (S.size() and c == expr[-1]):
                    return False
    return True




12강.
1회차 실습 작성코드
def solution(S):
    answer = ''
    opStack = ArrayStack()
    cnt=0
    for c in S:
        if c in prec: 
            #괄호면 무조건 넣겠다
            if c=='(' or opStack.isEmpty():
                opStack.push(c)
                
            elif prec[opStack.peek()] >= prec[c]:        
        #딕셔너리에 없는걸 물었을 때 무엇을 반환할까? //이것도 미룰 수 있네.. if 에서 쳐내고있으므로
                #맨꼭대기만 뽑는게 아님
                while not opStack.isEmpty() and prec[opStack.peek()] >= prec[c]:
                    answer=answer+opStack.pop()
                
                opStack.push(c)
        #스택에 아무것도 없을떄 어떻게 초기화할지? ... 이 문제는 다음으로 미룰 수 있다
            elif prec[opStack.peek()] < prec[c]:
                opStack.push(c)
        else:
            if c==')':
                while opStack.peek()!='(':
                    answer=answer+opStack.pop()
                opStack.pop()
                
                
            else: #진짜 문자일때
                answer=answer+c
        
        if cnt==len(S)-1:
            while not opStack.isEmpty():
                answer=answer+opStack.pop()   
                
        cnt=cnt+1        
    return answer

—— 실습 2회차 내 코드

def solution(S):
    opStack = ArrayStack()
    answer = ''
    for c in S:
        if c in prec:
            #맨처음 연산자는 무조건 푸쉬
            if opStack.isEmpty():            
                opStack.push(c)
            else:
                if c == '(':
                    opStack.push(c)
                else:
                    if prec[c]<=prec[opStack.peek()]:
                        while (not opStack.isEmpty()) and (prec[opStack.peek()] >= prec[c]): #다 뺸 다음에도 돌아가는가?
                            answer+=opStack.pop()
                        opStack.push(c)
                    else:
                        opStack.push(c)
        else:
            if c == ')':
                while opStack.peek()!='(':
                    answer+=opStack.pop()
                opStack.pop()
            else:
                answer+=c
                        
    while opStack.isEmpty() is False:
        answer+=opStack.pop() 
            
    return answer


13강.
실습 1회차 내 코드

def infixToPostfix(tokenList):
    prec = {
        '*': 3,
        '/': 3,
        '+': 2,
        '-': 2,
        '(': 1,
    }

    opStack = ArrayStack()
    postfixList = []
    
    for token in tokenList:
        if type(token) is int:
            postfixList.append(token)
        elif token == '(':
            opStack.push(token)
        elif token in prec:
            if opStack.isEmpty():
                opStack.push(token)
            else:
                if prec[opStack.peek()] >= prec[token]:
                    while not opStack.isEmpty() and prec[opStack.peek()]>=prec[token]:
                        postfixList.append(opStack.pop())
                    opStack.push(token)
                        
                else:
                    opStack.push(token)
                    
        elif token==')':
            while opStack.peek()!='(':
                postfixList.append(opStack.pop())
            opStack.pop()
        
    while not opStack.isEmpty():
        postfixList.append(opStack.pop())
    print(postfixList)
    return postfixList


def postfixEval(tokenList):
    S=ArrayStack()
    k=0
    pop1=0
    pop2=0
    for token in tokenList:
        if type(token) is int:
            S.push(token)
        elif token=='*':
            pop1=S.pop()
            pop2=S.pop()
            k=pop2*pop1
            S.push(k)
        elif token=='+':
            pop1=S.pop()
            pop2=S.pop()
            k=pop2+pop1
            S.push(k)
        elif token=='/':
            pop1=S.pop()
            pop2=S.pop()
            k=pop2/pop1
            S.push(k)
        elif token=='-':
            pop1=S.pop()
            pop2=S.pop()
            k=pop2-pop1
            S.push(k)
    val=S.pop()
    return val


실습 2회차 내 코드
def infixToPostfix(tokenList):
    prec = {
        '*': 3,
        '/': 3,
        '+': 2,
        '-': 2,
        '(': 1,
    }

    opStack = ArrayStack()
    postfixList = []
    
    for c in tokenList:
        if c in prec: #연산자를 만나는 경우 스택에 쌓는다
            if opStack.isEmpty():
                opStack.push(c)
            else:
                if c=='(': #여는 괄호여도 무조건 쌓는다
                    opStack.push(c)
                else:
                    if prec[c]<=prec[opStack.peek()]: #스택에 있는게 더 크거나 같으면, c보다 작아질때까지 계속 뽑아서 추가
                        while not opStack.isEmpty() and prec[opStack.peek()]>=prec[c]:
                            postfixList.append(opStack.pop())
                    opStack.push(c)
                    
        elif c==')': #여는 괄호를 만날때 까지 다 뺀다
            while opStack.peek() != '(':
                postfixList.append(opStack.pop())
            opStack.pop()
        else:# 숫자를 만나면 바로 추가 >> type()==int 이렇게 해서 풀 수도 있다
            postfixList.append(c)
            
    while opStack.isEmpty() ==False: #스택이 빌 때까지 팝해서 추가
        postfixList.append(opStack.pop())

    return postfixList


def postfixEval(tokenList):
    S=ArrayStack() #숫자 담을 것
    
    for k in tokenList: 
        if type(k)==int:
            S.push(k)
        else:
            pop1=S.pop()
            pop2=S.pop()
            if k=='*':    
                S.push(pop2*pop1)
            elif k=='+':
                S.push(pop2+pop1)
            elif k=='-':
                S.push(pop2-pop1)
            else:
                S.push(pop2/pop1)
    return S.pop()        
    

14강 실습
1회차 내 코드

class LinkedListQueue:

    def __init__(self):
        self.data = DoublyLinkedList()

    def size(self):
        return self.data.getLength()

    def isEmpty(self):
        return self.data.getLength()==0

    def enqueue(self, item):
        node = Node(item)
        self.data.insertAt(self.data.nodeCount+1,node)

    def dequeue(self):
        return self.data.popAt(1)

    def peek(self):
        return self.data.getAt(1).data


def solution(x):
    return 0

2회차 내 코드 ::: 클래스의 이해가 늘어난 것은 확연히 보이지만 연산의 속도로 볼때 1회차 코드가 더 좋다. 이유는,  1회차에서는 size 연산이 없기 때문이다

class LinkedListQueue:

    def __init__(self):
        self.data = DoublyLinkedList()

    def size(self):
        return self.data.getLength()


    def isEmpty(self):
        return self.size()==0


    def enqueue(self, item):
        node = Node(item)
        self.data.insertAfter(self.data.head,node)


    def dequeue(self):
        return self.data.popAt(self.size())


    def peek(self):
        return self.data.getAt(self.size()).data




15강.

실습 1회차 코드

def enqueue(self, x):
        if self.isFull():
            raise IndexError('Queue full')
        self.rear = (self.rear+1)%self.maxCount
        self.data[self.rear] = x
        self.count += 1

    def dequeue(self):
        if self.isEmpty():
            raise IndexError('Queue empty')
        self.front = (self.front+1)%self.maxCount
        x = self.data[self.front]
        self.count -= 1
        return x

    def peek(self):
        if self.isEmpty():
            raise IndexError('Queue empty')
        return self.data[(self.front+1)%self.maxCount]

ㄴ>실습 2회차 상동


16강.
실습 1회차 코드
def enqueue(self, x):
        newNode = Node(x)
        curr = self.queue.head
        while curr.next!=self.queue.tail and curr.next.data>=x:
            curr = curr.next
        self.queue.insertAfter(curr, newNode)

2회차 코드
def enqueue(self, x):
        newNode = Node(x)
        curr = self.queue.head
        while curr.next.next and curr.next.data>=x:
            curr = curr.next
        self.queue.insertAfter(curr, newNode)

 17강.
연결리스트 / 스택 / 큐 (자료구조가 일렬로 선형적으로 이루어진 형태) 와 다르게 2차원적인 요소로 담고있는 모양 -> 트리


18강.

18-1
1회차 내 코드

노드
 def depth(self):
        l=self.left.depth() if self.left else 0
        r=self.right.depth() if self.right else 0
        maxx=l+1 if l>=r else r+1
        return maxx

트리
 def depth(self):
        if self.root:
            return self.root.depth()
        else:
            return 0

ㄴ2회차 코드 상동 : Node값이 None인 경우에는 절대 비교할 수가 없기 때문에 존재여부를 따지는 것은 필수다



18-2.
1회차 내 코드
노드
def preorder(self):
        traversal=[]
        traversal.append(self.data)
        if self.left:
            traversal+=self.left.preorder()
        if self.right:
            traversal+=self.right.preorder()
        
        return traversal

트리
    def preorder(self):
        if self.root:
            return self.root.preorder()
        else:
            return []


18-3도 1회차와 모두 동일하다



 
자료구조와 알고리즘
 
19강
 
실습 1회차 내 코드
def bft(self):
        if self.root:
            S=ArrayQueue()
            S.enqueue(self.root)
            
            traversal=[]
            while not S.isEmpty():
                k=S.dequeue()
                traversal+=k.data
                if k.left:
                    S.enqueue(k.left)
                if k.right:
                    S.enqueue(k.right)
        else:
            return []
        return traversal
 
2회차--- :::: 루트의 존재 여부를 따지는 점에서 좀 더 나아졌다
    def bft(self):
        travals=[]
        
        q=ArrayQueue() #q생성
        if self.root:        
            q.enqueue(self.root)
    
        while q.isEmpty() is False:
            node=q.dequeue()
            travals.append(node.data)
            if node.left:
                q.enqueue(node.left)
            if node.right:
                q.enqueue(node.right)
        return travals
 
 
20강. 이진 탐색 트리
 
1회차 내 실습 코드----------
 
노드
def insert(self, key, data):
        if self.key == key:
            raise KeyError
        elif key < self.key:
            if self.left:
                self.left.insert(key,data)
            else:
                self.left=Node(key,data)
        else:
            if self.right:
                self.right.insert(key,data)
            else:
                self.right=Node(key,data)
 
 
2회차 상동 (완전 같지는 않으나 피드백 필요한 부분은 없음)
 
 
21강 
이진 탐색트리는 1,2,3,4 순으로 insert하면
선형의 모양을 가지기 때문에 N^2의 복잡도를 가진다.
 

1회차 실습 코드
def remove(self, key):
        node, parent = self.lookup(key)
        if node:
            nChildren = node.countChildren()
            # The simplest case of no children
            if nChildren == 0:
                # 만약 parent 가 있으면
                # node 가 왼쪽 자식인지 오른쪽 자식인지 판단하여
                # parent.left 또는 parent.right 를 None 으로 하여
                # leaf node 였던 자식을 트리에서 끊어내어 없앱니다.
                if parent:
                    if parent.left:
                        if parent.left.key==key:
                            parent.left=None
                        else:
                            parent.right=None
                    elif parent.right:
                        if parent.right.key==key:
                            parent.right=None
                        else:
                            parent.left=None
                # 만약 parent 가 없으면 (node 는 root 인 경우)
                # self.root 를 None 으로 하여 빈 트리로 만듭니다.
                else:
                    self.root=None
                    
            
            # When the node has only one child
            elif nChildren == 1:
                # 하나 있는 자식이 왼쪽인지 오른쪽인지를 판단하여
                # 그 자식을 어떤 변수가 가리키도록 합니다.
                if node.left:
                    k=node.left
                else:
                    k=node.right
                # 만약 parent 가 있으면
                # node 가 왼쪽 자식인지 오른쪽 자식인지 판단하여
                # 위에서 가리킨 자식을 대신 node 의 자리에 넣습니다.
                if parent:
                    if parent.left.key==node.key:
                        parent.left=k
                    elif parent.right.key==node.key:
                        parent.right=k
                # 만약 parent 가 없으면 (node 는 root 인 경우)
                # self.root 에 위에서 가리킨 자식을 대신 넣습니다.
                else:
                    self.root=k
            # When the node has both left and right children
            else:
                parent = node
                successor = node.right
                # parent 는 node 를 가리키고 있고,
                # successor 는 node 의 오른쪽 자식을 가리키고 있으므로
                # successor 로부터 왼쪽 자식의 링크를 반복하여 따라감으로써
                # 순환문이 종료할 때 successor 는 바로 다음 키를 가진 노드를,
                # 그리고 parent 는 그 노드의 부모 노드를 가리키도록 찾아냅니다.
                while successor.left:
                    parent=successor
                    successor=successor.left
                # 삭제하려는 노드인 node 에 successor 의 key 와 data 를 대입합니다.
                node.key = successor.key
                node.data = successor.data
                # 이제, successor 가 parent 의 왼쪽 자식인지 오른쪽 자식인지를 판단하여
                # 그에 따라 parent.left 또는 parent.right 를
                # successor 가 가지고 있던 (없을 수도 있지만) 자식을 가리키도록 합니다.
                if parent.key!=key:
                    parent.left=successor.right
                else:
                    parent.right=successor.right
                    
            return True
        else:
            return False

——2회차 내 실습 코드
def remove(self, key):
        node, parent = self.lookup(key)
        if node:
            nChildren = node.countChildren()
            # The simplest case of no children
            if nChildren == 0:
                # 만약 parent 가 있으면
                # node 가 왼쪽 자식인지 오른쪽 자식인지 판단하여
                # parent.left 또는 parent.right 를 None 으로 하여
                # leaf node 였던 자식을 트리에서 끊어내어 없앱니다.
                if parent:
                    if parent.left==node:
                        parent.left=None
                    else:
                        parent.right=None
                # 만약 parent 가 없으면 (node 는 root 인 경우)
                # self.root 를 None 으로 하여 빈 트리로 만듭니다.
                else:
                    self.root=None
            # When the node has only one child
            elif nChildren == 1:
                # 하나 있는 자식이 왼쪽인지 오른쪽인지를 판단하여
                # 그 자식을 어떤 변수가 가리키도록 합니다.
                if node.left:
                    ss=node.left
                else:
                    ss=node.right
                # 만약 parent 가 있으면
                # node 가 왼쪽 자식인지 오른쪽 자식인지 판단하여
                # 위에서 가리킨 자식을 대신 node 의 자리에 넣습니다.
                if parent:
                    if parent.left==node:
                        parent.left=ss
                    else:
                        parent.right=ss
                    
                # 만약 parent 가 없으면 (node 는 root 인 경우)
                # self.root 에 위에서 가리킨 자식을 대신 넣습니다.
                else:
                    self.root=ss
            # When the node has both left and right children
            else:
                parent = node
                successor = node.right
                # parent 는 node 를 가리키고 있고,
                # successor 는 node 의 오른쪽 자식을 가리키고 있으므로
                # successor 로부터 왼쪽 자식의 링크를 반복하여 따라감으로써
                # 순환문이 종료할 때 successor 는 바로 다음 키를 가진 노드를,
                # 그리고 parent 는 그 노드의 부모 노드를 가리키도록 찾아냅니다.
                while successor.left:
                    parent=successor
                    successor=successor.left
                # 삭제하려는 노드인 node 에 successor 의 key 와 data 를 대입합니다.
                node.key = successor.key
                node.data = successor.data
                # 이제, successor 가 parent 의 왼쪽 자식인지 오른쪽 자식인지를 판단하여
                # 그에 따라 parent.left 또는 parent.right 를
                # successor 가 가지고 있던 (없을 수도 있지만) 자식을 가리키도록 합니다.
                if parent.left==successor:
                        parent.left=successor.right
                else:#x와 p가 같은 경우
                        parent.right=successor.right               
            return True

        else:
            return False





————————힙————————

힙 삽입 -  이경우에 최대 root노드까지 올라가나, 깊이는 logN이므로 logN의 복잡도를 가진다.

힙 정렬 - 이 경우에 맥스힙의 경우 루트노드는 항상 최대임이 보장되므로 루트를 차례대로 꺼내면 내림차순 정렬이 가능하며, 반대로 오름차순 정렬도 가능하다!
둘다 복잡도는 당연 logN을 가진다.




1회차 내 코드
class MaxHeap:

    def __init__(self):
        self.data = [None]


    def insert(self, item):
        self.data.append(item) #맨  뒤  넣음
        ll=len(self.data)-1
        lldiv=ll//2

        if ll==1:
            return True
        else:
            while ll!=1 and self.data[lldiv] <= self.data[ll]:
                self.data[lldiv],self.data[ll]=self.data[ll],self.data[lldiv]
                ll=lldiv
                lldiv=ll//2

def solution(x):
    return 0

2회차 내 코드
class MaxHeap:

    def __init__(self):
        self.data = [None]

    def insert(self, item):
        self.data.append(item)

        index=len(self.data)-1
        root=index//2
        while self.data[root]:
            if self.data[root]<self.data[index]:
                self.data[root],self.data[index]=self.data[index],self.data[root]
                index=root
                root=index//2
            else:
                return True




—— 힙 마지막 강의 ——
1회차 내 코드

class MaxHeap:

    def __init__(self):
        self.data = [None]


    def remove(self):
        if len(self.data) > 1:
            self.data[1], self.data[-1] = self.data[-1], self.data[1]
            data = self.data.pop(-1)
            self.maxHeapify(1)
        else:
            data = None
        return data


    def maxHeapify(self, i):
        # 왼쪽 자식 (left child) 의 인덱스를 계산합니다.
        left = i*2
        # 오른쪽 자식 (right child) 의 인덱스를 계산합니다.
        right = i*2+1
        smallest = i
        # 왼쪽 자식이 존재하는지, 그리고 왼쪽 자식의 (키) 값이 (무엇보다?) 더 큰지를 판단합니다.
        if left<=len(self.data)-1 and (self.data[left] > self.data[smallest]):
            # 조건이 만족하는 경우, smallest 는 왼쪽 자식의 인덱스를 가집니다.
            smallest=left
        # 오른쪽 자식이 존재하는지, 그리고 오른쪽 자식의 (키) 값이 (무엇보다?) 더 큰지를 판단합니다.
        if right<=len(self.data)-1 and (self.data[right] > self.data[smallest]):
            # 조건이 만족하는 경우, smallest 는 오른쪽 자식의 인덱스를 가집니다.
            smallest=right
        if smallest != i:
            # 현재 노드 (인덱스 i) 와 최댓값 노드 (왼쪽 아니면 오른쪽 자식) 를 교체합니다.
            self.data[smallest], self.data[i] = self.data[i], self.data[smallest]
            # 재귀적 호출을 이용하여 최대 힙의 성질을 만족할 때까지 트리를 정리합니다.
            self.maxHeapify(smallest)


2회차 내 코드 ==> 상동


